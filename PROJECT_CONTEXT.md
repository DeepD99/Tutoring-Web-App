Roles + what each role can do Roles Student: creates a session request Parent/Guardian: approves/rejects requests for their student (and can see history) Tutor: accepts/declines approved requests; delivers session Admin: sees everything; can override, match, debug What “existing platforms” standardize A single source of truth record (“booking” or “session request”) with a status Role-based views (each role sees the same object, filtered differently) Approval gates (some roles can only act when prior gate is satisfied) 2) The minimal state machine (implement this first) Use one status field (enum) + an audit log. Status enum DRAFT (optional) – student filling form PENDING_PARENT_APPROVAL REJECTED_BY_PARENT APPROVED_BY_PARENT PENDING_TUTOR_ACCEPTANCE (or combine with #4) DECLINED_BY_TUTOR CONFIRMED CANCELLED COMPLETED NO_SHOW (optional) Allowed transitions Student: → PENDING_PARENT_APPROVAL (submit), or cancel Parent: PENDING_PARENT_APPROVAL → APPROVED_BY_PARENT | REJECTED_BY_PARENT Tutor: APPROVED_BY_PARENT → CONFIRMED | DECLINED_BY_TUTOR Admin: can set any status + override tutor assignment This alone gives you the “approval chain” cleanly. 3) Database tables (minimal but real) A) users id (auth id) role (student|parent|tutor|admin) name, email B) families id name C) family_members family_id user_id relationship (student|parent) (optional) student_user_id if you want explicit parent→student mapping D) session_requests (THE core object) id student_id parent_id (can be null if not needed) tutor_id (nullable until matched) subject / course requested_start_time, duration_minutes location_type (online|in_person) notes status (enum above) created_at, updated_at E) request_events (audit trail + notifications source) id request_id actor_user_id event_type (created|approved|rejected|assigned|accepted|declined|cancelled|completed) metadata (json) created_at Platforms that “feel professional” always have an audit/event log. It also makes debugging approvals easy. 4) Row-level security / access rules (critical) Whether you use Supabase or your own backend, implement these rules: session_requests visibility Student: can read where student_id = auth.uid() Parent: can read where parent_id = auth.uid() OR belongs to same family as student Tutor: can read where tutor_id = auth.uid() OR where status = APPROVED_BY_PARENT and it’s in the tutor’s eligible pool Admin: can read all session_requests update rules Student: can update only when status in (DRAFT, PENDING_PARENT_APPROVAL) and only their own; can cancel Parent: can update only PENDING_PARENT_APPROVAL to approved/rejected for linked student Tutor: can update only requests assigned to them and in correct status Admin: can update anything This is the “approval gating” enforcement. UI alone isn’t enough. 5) API endpoints (implementable today) Student endpoints POST /requests → creates request with status=PENDING_PARENT_APPROVAL GET /requests?mine=true POST /requests/:id/cancel Parent endpoints GET /requests?pendingApproval=true POST /requests/:id/approve POST /requests/:id/reject Tutor endpoints GET /requests?assignedToMe=true POST /requests/:id/accept POST /requests/:id/decline Admin endpoints GET /requests (all + filters) POST /requests/:id/assign-tutor (sets tutor_id, moves status) POST /requests/:id/override-status Each endpoint: checks role + relationship checks current status writes new status inserts a request_events row 6) Pages you need (simple, shippable) Auth / onboarding /login /onboarding (collect role; if student/parent: join family) Student /student/new-request (form) /student/requests (list + status chips) /student/request/:id (detail) Parent /parent/approvals (queue: approve/reject) /parent/requests (history) /parent/request/:id (detail + child context) Tutor /tutor/requests (assigned queue + accept/decline) /tutor/request/:id (detail) Admin /admin/requests (table w filters + “Assign tutor” modal + status override) /admin/request/:id (audit log visible) That’s enough for a working MVP. 7) Notifications (what existing platforms do) Use event-driven notifications from request_events. Triggers On created → notify parent On approved/rejected → notify student (+ admin optional) On assigned → notify tutor On accepted/declined → notify student + parent + admin Implementation today Email via SendGrid/Postmark OR in-app notifications table If you’re already on Supabase: DB trigger → Edge Function → email 8) The “matching” model (start manual) Existing platforms usually start with manual matching (admin assigns tutor). Don’t overbuild. MVP Admin picks tutor in UI Sets tutor_id Status becomes APPROVED_BY_PARENT (if parent already approved) then tutor sees it Later upgrade: Auto-match by subject, grade, availability 9) What to build today, in order (fastest path) DB tables + status enum (session_requests, family_members, request_events) RLS/permissions (or server-side checks) Student create request Parent approvals queue Tutor accept/decline Admin requests table + assign tutor Audit log UI Notifications If you do those 8 steps, you’ll have a functioning, real workflow. 10) Copy-paste “implementation spec” (for your repo) Core rule: “All booking actions are status transitions. All transitions write an event.” Any action that changes a request: validate role validate relationship (student-parent family link) validate current_status update status insert into request_events That’s the spine of the product. You’re building a role-based tutoring and academic support platform for middle- and high-school students, where learners across grades 9–12 can request help in core academic subjects—English Language Arts (including honors and AP), mathematics from pre-algebra through AP Calculus AB/BC, science courses like biology, chemistry, and physics, and core social studies. Each session follows a structured approval chain: a student submits a request, a parent or guardian explicitly approves or rejects it, a qualified tutor accepts and delivers the session, and an admin oversees matching, compliance, and quality. The platform enforces permissions, visibility, and status transitions at the system level, creating a transparent, auditable workflow built specifically for minors where academic rigor, parental trust, and operational control are first-class features.
